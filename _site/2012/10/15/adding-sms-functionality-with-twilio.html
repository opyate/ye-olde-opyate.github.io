<!DOCTYPE HTML>
<html lang="en" prefix="og: http://ogp.me/ns#">
  <head>
    <meta charset="utf-8">
    <title>Adding SMS functionality with Twilio &mdash; Juan Uys</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <link href='http://fonts.googleapis.com/css?family=Poly:400,400italic' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" media="screen, projection" href="/res/screen.css" type="text/css">
    <link rel="stylesheet" media="print" href="/res/print.css" type="text/css">
    <link rel="alternate" type="application/atom+xml" title="Juan Uys" href="http://feeds.feedburner.com/opyate">
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="apple-touch-icon-precomposed" href="/res/apple-touch-icon-57x57-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/res/apple-touch-icon-72x72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/res/apple-touch-icon-114x114-precomposed.png">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@opyate">
    
    <meta property="fb:admins" content="564490402">
    <meta property="fb:app_id" content="318152194986912">
    
    <meta property="og:title" content="Adding SMS functionality with Twilio">
      
      <meta name="description" content="Adding SMS functionality with Twilio">
      <meta name="og:description" content="Adding SMS functionality with Twilio">
      
    
    
    <meta property="og:image" content="http://www.twilio.com/packages/company/img/logos_downloadable_round.png">
    
    <meta property="og:url" content="http://opyate.com/2012/10/15/adding-sms-functionality-with-twilio.html">
    <meta property="og:site_name" content="opyate.com">
    <meta property="og:type" content="article">
    <meta property="og:locale" content="en_GB" />
    
    <meta property="article:published_time" content="2012-10-15">
    
    
    <script>
  //html { zoom:50%; }
  if (window.addEventListener) {
    var sidebarAdjustTimer;
    function updateOrientation(orientationChangeEvent) {
      if (sidebarAdjustTimer) clearInterval(sidebarAdjustTimer);
      //console.log('window.orientation -> '+window.orientation);
      if (window.orientation === -90 || window.orientation === 90) {
        // landscape
        var sidebar = document.getElementById('sidebar');
        if (!sidebar.src || sidebar.src === '') {
          sidebar.src = '/archive/sidebar.html';
        }
        sidebarAdjustTimer = setInterval(function() {
          var height = Math.round(document.height * 1.6);
          if (sidebar.height != height) {
            sidebar.height = height;
            sidebar.style.height = height + 'px';
          }
        },500);
      } else {
        // portrait
      }
    }
    window.addEventListener('orientationchange', updateOrientation);
    document.addEventListener('DOMSubtreeModified', function(ev) {
      if (document.getElementById('sidebar')) {
        document.removeEventListener('DOMSubtreeModified', arguments.callee);
        updateOrientation();
      }
    });
  }
</script>
    
    
  </head>
  <body>
    <script>
      var s;
      if (document.location.hostname === 'opyate.com') {
        s = document.createElement('script');
        s.async = true;
        s.src = "http://connect.facebook.net/en_US/all.js#appId=318152194986912&xfbml=1";
        document.getElementsByTagName('head')[0].appendChild(s);
      }
      
      if (window.navigator.userAgent.indexOf('iPad') != -1) {
        document.documentElement.className = 'ios ipad';
        window.opyateHostIsIOS = 'ipad';
      } else if (window.navigator.userAgent.indexOf('iPhone') != -1) {
        document.documentElement.className = 'ios iphone';
        window.opyateHostIsIOS = 'iphone';
      }
    </script>
    <div id="fb-root"></div><script></script>
    <iframe id="sidebar"></iframe>
    <header>
      <h1 class="logo" onclick="document.location.href='/';"><a href="/"><img src="/res/signature-2-2.png" width="160" height="50" alt="Signature"></a></h1>
      <ul class="navigation">
        <li><a href="/projects/" title="Projects I am or was involved in">Projects</a></li>
        <li><a href="/archive/" title="Archived articles">Archive</a></li>
        <li><a href="/about/">About me</a></li>
      </ul>
    </header>
    <!--div class="wrapper content"-->
      <div class="content">
  <div class="post single">
	<div class="meta">
		<p class="item tags small">
		<a href="/tag/tech" class="tag">tech</a><a href="/tag/scala" class="tag">scala</a><a href="/tag/twilio" class="tag">twilio</a><a href="/tag/pollarize" class="tag">pollarize</a>
		</p>
	</div>
	<div class="breaker"></div>
    <h1>Adding SMS functionality with Twilio</h1>

    <info datetime="2012-10-15">
      Oct 15, 2012
    </info>


    <div class="body"><p><a href="http://pollarize.me">Pollarize</a> helps the world make up its mind via its beautiful, delightful suite of apps. However, not everyone owns a smartphone. Luckily, <a href="http://www.twilio.com/">Twilio</a> brings voice and messaging to web and mobile applications. Which means that Pollarize now allows our brick-lugging friends to compose polls via SMS.</p>

<h1>How we built it</h1>

<p>The usual Pollarize system constraints are the following:</p>

<ul>
<li>poll question can not exceed 100 characters</li>
<li>options A and B can not exceed 100 characters each</li>
</ul>


<p>The requirements are the following:</p>

<ul>
<li>a poll SMS should be in the format “Question text. A. First option B. Second option”</li>
<li>if either A or B is omitted, then default to “Yes” and “No” respectively</li>
<li>a poll SMS can exceed the 160 character limit, but not exceed 308 characters if we take into account the delimiters ” A. ” and ” B. “</li>
</ul>


<p>This meant that an entire poll can at least be described at least by one SMS, and at most by two, since 308 is less than 2 * 160, or two SMS fragments.</p>

<h1>SMS</h1>

<p>Twilio seemingly don’t maintain any state on their side. I.e. if a user sends a large SMS, Twilio will not bundle the resulting SMS fragments up and send it to us in one piece. Instead, Twilio will send us the fragments one after the other as they become available from the mobile network.</p>

<p>To illustrate this, here are the <code>application/form-url-encoded</code> payloads represented as Scala maps:</p>

<script src='https://gist.github.com/3854971.js?file=TwilioSMSFirst.scala'></script>


<div><noscript><pre><code>Map(
 ToCountry -&gt; List(GB),
 ToState -&gt; List(London),
 SmsMessageSid -&gt; List(SMc508bc45e41be7ec3827ac6b9617fb62),
 ToCity -&gt; List(),
 FromZip -&gt; List(),
 SmsSid -&gt; List(SMc508bc45e41be7ec3827ac6b9617fb62),
 FromState -&gt; List(),
 SmsStatus -&gt; List(received),
 FromCity -&gt; List(),
 Body -&gt; List(I don&#39;t have an iPhone, so I thought I&#39;d build SMS functionality. A. Great, what about something that interprets smoke signals? B. Good, now get on with ),
 FromCountry -&gt; List(GB),
 To -&gt; List(+442033224667),
 ToZip -&gt; List(),
 AccountSid -&gt; List(AC78cccde86008c911f6ae6a1c575b575a),
 From -&gt; List(+447446112182),
 ApiVersion -&gt; List(2010-04-01))</code></pre></noscript></div>




<script src='https://gist.github.com/3854971.js?file=TwilioSMSSecond.scala'></script>


<div><noscript><pre><code>Map(
 ToCountry -&gt; List(GB),
 ToState -&gt; List(London),
 SmsMessageSid -&gt; List(SM3f5c6a4584270d38ccbd1641a7b83df4),
 ToCity -&gt; List(),
 FromZip -&gt; List(),
 SmsSid -&gt; List(SM3f5c6a4584270d38ccbd1641a7b83df4),
 FromState -&gt; List(),
 SmsStatus -&gt; List(received),
 FromCity -&gt; List(),
 Body -&gt; List(the Android app already!),
 FromCountry -&gt; List(GB),
 To -&gt; List(+442033224667),
 ToZip -&gt; List(),
 AccountSid -&gt; List(AC78cccde86008c911f6ae6a1c575b575a),
 From -&gt; List(+447446112182),
 ApiVersion -&gt; List(2010-04-01))</code></pre></noscript></div>


<h1>Implementation in a nutshell</h1>

<p>The trick here is to assemble the SMS text once we’ve received all the fragments. Since Twilio doesn’t tell us there’s a second fragment coming, we don’t create a poll immediately after an SMS is received. Instead, we dump the payloads into MongoDB as they are received. A background worker then scans all “unprocessed” SMSes and check if there were other SMSes <em>from the same phone number within the last 10 seconds</em>. Once we have all the SMSes, we combine the original SMS text into a single text, create the poll, and we mark the Mongo record as “processed”.</p>

<p>The “<em>within the last 10 seconds</em>” bit only came after I discovered a massive bug. Let me explain…</p>

<h1>The Poll-from-SMS scheduled job</h1>

<p>The background job server re-assembles the SMS fragments into a single SMS and checks if they’re poll-worthy.</p>

<p>The first version of the SMSWorker accidentally did the following (using the data from the two Gists above):</p>

<h2>Poll #1</h2>

<pre>
Question: I don't have an iPhone, so I thought I'd build SMS functionality.
Option A. Great, what about something that interprets smoke signals?
Option B. Good, now get on with
</pre>


<h2>Poll #2</h2>

<pre>
Question: the Android app already!
Option A: Yes
Option B: No
</pre>


<p>See what I did there? Option B got cut off due to the 160 character SMS limit, and we accidentally created a whole new, unintelligible poll. Not quite what I had in mind, as you can imagine. I had to start making some assumptions about the way Twilio and the mobile networks interact in light of the absence of an SLA from either.</p>

<p>I assumed a maximum of 10 seconds between SMS fragments. A counter point to this is that we assume a user won’t create polls via SMS in quick succession.</p>

<h1>The Poll-from-SMS scheduled job V2</h1>

<p>The second version of the SMSWorker can be seen below.</p>

<script src='https://gist.github.com/3854971.js?file=ScheduledPollFromSMSActor.scala'></script>


<div><noscript><pre><code>class ScheduledPollFromSMSActor extends Actor with ActorLogging {
  def receive = {
    case &quot;check&quot; =&gt; {
      // find all &quot;unprocessed&quot; SMSes
      val twilios = TwilioMongo.findAllUnprocessed()

      // we don&#39;t assume that users will send short SMSes in a short amount of time
      twilios.groupBy(t =&gt; t.smsdata(&quot;From&quot;)).map {
        case (mobile, data) =&gt; {
          // take the user&#39;s SMSes where they&#39;re 10 seconds from one another
          val first = data.head
          val inProximity = data.takeWhile(d =&gt; scala.math.abs(d.created - first.created) &lt; 10000L)

          // assemble the entire SMS
          val entireSMS = inProximity.foldLeft(&quot;&quot;)((a, v) =&gt; {
            a + v.smsdata(&quot;Body&quot;)
          })

          val parsed = SMSParser(entireSMS)
          
          // &lt;omitted&gt; create poll, notify user, broadcast to other listeners...
          
          // mark as processed, or failed
          inProximity.map(twilioData =&gt; {
            TwilioMongo.update(twilioData.copy(status = parsed.map(_ =&gt; &quot;processed&quot;).getOrElse(&quot;failed&quot;)))
          })
        }
      }
    }
  }
}</code></pre></noscript></div>


<p>The value inProximity are the SMS fragments within a 10 second period. The SMS fragments belong to the same user, as obtained via the groupBycall on line 8.</p>

<p>The SMSParser on line 19 is really nothing special, but from the test cases you’ll see that we’re catering for every eventuality:</p>

<script src='https://gist.github.com/3854971.js?file=SMSParserSpec.scala'></script>


<div><noscript><pre><code>class SMSParserSpec extends Specification {
  
  // one hundred characters
  val h = &quot;0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789&quot;
  // MORE than one hundred characters
  val h1 = &quot;0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789&quot; + &quot;!&quot;
 
  // --
  
  &quot;SMS Parser&quot; should {
    
    &quot;extract question and 2 answers&quot; in {
      val poll = SMSParser(&quot;Was this sent via SMS? a. Yes, indeed. b. Nope!&quot;)
      
      poll.get.question.trim must equalTo(&quot;Was this sent via SMS?&quot;)
      poll.get.option_a.get.trim must equalTo(&quot;Yes, indeed.&quot;)
      poll.get.option_b.get.trim must equalTo(&quot;Nope!&quot;)
    }
    
    &quot;default to Yes and No when no answers are specified&quot; in {
      val poll = SMSParser(&quot;Cheese is da bomb!&quot;)
      
      poll.get.question must equalTo(&quot;Cheese is da bomb!&quot;)
      poll.get.option_a must beSome(&quot;Yes&quot;)
      poll.get.option_b must beSome(&quot;No&quot;)
    }
    
    &quot;ignore the case of a and b&quot; in {
      val poll = SMSParser(&quot;Was this sent via SMS? A. Yes, indeed. b. Nope!&quot;)
      
      poll.get.question must equalTo(&quot;Was this sent via SMS?&quot;)
      poll.get.option_a.get.trim must equalTo(&quot;Yes, indeed.&quot;)
      poll.get.option_b.get.trim must equalTo(&quot;Nope!&quot;)
    }
    
    &quot;default b to &#39;No&#39; if only a is specified&quot; in {
      val poll = SMSParser(&quot;Was this sent via SMS? A. Yes, indeed.&quot;)
      
      poll.get.question must equalTo(&quot;Was this sent via SMS?&quot;)
      poll.get.option_a.get.trim must equalTo(&quot;Yes, indeed.&quot;)
      poll.get.option_b must beSome(&quot;No&quot;)
    }
    
    &quot;default a to &#39;Yes&#39; if only b is specified&quot; in {
      val poll = SMSParser(&quot;Was this sent via SMS? B. This is only a dream.&quot;)
      
      poll.get.question must equalTo(&quot;Was this sent via SMS?&quot;)
      poll.get.option_a must beSome(&quot;Yes&quot;)
      poll.get.option_b.get.trim must equalTo(&quot;This is only a dream.&quot;)
    }
    
    &quot;be invalid if only options were specified (i.e. no question)&quot; in {
      SMSParser(&quot;A. Yes, indeed. B. This is only a dream.&quot;) must beNone
      SMSParser(&quot;A. Yes, indeed.&quot;) must beNone
      SMSParser(&quot;B. This is only a dream.&quot;) must beNone
    }
    
    &quot;be invalid if nothing at all was specified&quot; in {
      SMSParser(&quot;&quot;) must beNone
      SMSParser(&quot; &quot;) must beNone
      SMSParser(&quot;  &quot;) must beNone
    }
    
    &quot;reject the SMS if any/all fields are &gt; 100&quot; in {
      val poll = SMSParser(&quot;%s A. %s B. %s&quot;.format(h, h, h))
      poll.get.question must equalTo(h)
      poll.get.option_a must beSome(h)
      poll.get.option_b must beSome(h)
      
      SMSParser(&quot;%s A. %s B. %s&quot;.format(h1, h, h)) must beNone
      SMSParser(&quot;%s A. %s B. %s&quot;.format(h, h1, h)) must beNone
      SMSParser(&quot;%s A. %s B. %s&quot;.format(h, h, h1)) must beNone
      SMSParser(&quot;%s A. %s B. %s&quot;.format(h1, h1, h1)) must beNone
    }
  }
}</code></pre></noscript></div>


<h1>Conclusion</h1>

<p>This was a fun little addition. Next up is voting via SMS.</p>

<p>MongoDB allowed me to store the entire SMS payload and worry about the contents later. I didn’t create a model for the SMS payload, because it isn’t core to my domain. Also, the 10 second window seemed like a safe trade-off in light of being in the dark (huh?) with regards to mobile network SLAs. We’ll measure and adjust accordingly, of course.</p>

<p>Twilio was easy to integrate with, and it all just works. Now I feel like SMS-enabling all my apps.</p>

<p><img width="50%" src="http://cdn.memegenerator.net/instances/400x/28084623.jpg" alt="SMS-enable all the things"></p>
</div>
    <div class="breaker"></div>

    <info class="after">
<div class="fb-like" data-href="http://opyate.com/2012/10/15/adding-sms-functionality-with-twilio.html" data-send="false" data-width="550" data-show-faces="false" data-font="arial"></div>
    </info>

  
  </div>
</div>

<script type="text/javascript">
(function() {
var qs = document.location.search;
var current_etag = qs.match(/etag=("?[a-zA-Z0-9_-]+)/);
if (current_etag !== null) { current_etag = current_etag[1]; }
var scrolly = qs.match(/scrolly=([0-9]+)/);
if (scrolly) {
  scrolly = parseInt(scrolly[1]);
  window.scrollTo(window.scrollX, scrolly);
  setTimeout(function () {
    window.scrollTo(window.scrollX, scrolly);
  }, 10);
}

function check() {
  var r = new XMLHttpRequest();
  var url = document.location.href + ((qs && qs !== '') ? '&' : '?') + 'r=' + Math.random();
  r.open('GET', url, true);
  r.onreadystatechange = function() {
    if (r.readyState == 4){
      var found_etag = r.getResponseHeader('Etag').replace(/^"|"$/g);
      //console.log('current_etag:', current_etag, 'found_etag:', found_etag);
      if (current_etag === null) {
        current_etag = found_etag;
      } else if (found_etag !== current_etag) {
        document.location.search =
          '?etag=' + encodeURIComponent(found_etag) +
          '&scrolly=' + window.scrollY;
        return;
      }
      setTimeout(check, 500);
    }
  };
  r.send(null);
}
check();
})();
</script>


    <!--/div-->
    
    
    <div class="content sub">
      <h2 id="comments">Comments</h2>
      <div class="fb-comments" data-href="http://opyate.com/2012/10/15/adding-sms-functionality-with-twilio.html" data-num-posts="" data-width="550" data-font="arial"></div>
    </div>
    
    
    
    
    
    <footer>
      <p>
        <a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.en_US" class="cc"><img src="/res/cc-cc.png" class="cc">
        <img src="/res/cc-by.png" class="cc"></a>
        This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons License</a>
      </p>
    </footer>
    
    
    <script>
  // curry pre < code to be able to get prettified
  // If the first line is
  //   #!-langname\n
  // Then that line is removed from the code and "langname" is given to prettify.
  // If "langname" is "none", that prettify is not applied at all.
  var n,i,L,cn,lang,v = document.getElementsByTagName('pre');
  var m,lang_re = /^#\!-([a-zA-Z0-9_-]+)\n/;
  for (i=0,L=v.length;i<L;++i) {
    n = v.item(i);
    if ((cn = n.firstChild) && cn.nodeName == 'CODE') {
      lang = null;
      if (cn.firstChild.nodeType === Node.TEXT_NODE) {
        m = lang_re.exec(cn.firstChild.nodeValue);
        if (m) {
          lang = m[1].toLowerCase();
          cn.firstChild.nodeValue = cn.firstChild.nodeValue.substr(m[0].length);
          if (lang === 'none') {
            continue;
          }
        }
      }
      n.setAttribute('class', 'prettyprint'+(lang ? ' lang-' + lang : ''));
    }
  }
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>

    <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28222168-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </body>
</html>
